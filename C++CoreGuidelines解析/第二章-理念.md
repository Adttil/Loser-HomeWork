# 理念

理念性规则概览：

* [P.1: 在代码中直接表达思想](#p1-在代码中直接表达思想)
* [P.2: 用 ISO 标准 C++ 来写代码](#p2-用-iso-标准写代码)
* [P.3: 表达意图](#p3-表达意图)
* [P.4: 理想情况下，程序应该是静态类型安全的]()
* [P.5: 编译期检查优先于运行期检查]()
* [P.6: 不能在编译期检查的事项应该在运行期检查]()
* [P.7: 尽早识别运行期错误]()
* [P.8: 不要泄漏任何资源]()
* [P.9: 不要浪费时间和空间]()
* [P.10: 不可变数据优先于可变数据]()
* [P.11: 杂乱的构造封装起来，不要让它散布到代码中]()
* [P.12: 适当使用支持工具]()
* [P.13: 适当使用支持程序库]()

理念性规则强调一般性，因此，无法进行检查。不过，理念性规则为下面的具体规则提供了理论依据。一共有 13 条理念性规则。

> 如果觉得没听懂不用在意，的确有点抽象，可以简单理解为一般情况下的编码规范。

## P.1 在代码中直接表达思想

编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。 而代码中所表达的东西是带有 **明确的语义** 的，并且（原则上）是可以由编译器和其他工具进行检验的。

```cpp
class Date {
public:
    Month month() const;  // 好
    int month();          // 不好
    // ...
};
```

第一个 `moth` 比第二个，有更多的信息，以 `const` 修饰，代表不会修改当前的日期，返回类型 `Month` 也非常明确。

> 根据我的一般经验，起码有一半的 `C++` 开发者不懂成员函数修饰 `const` 是为什么，能做什么。只是默认，不修改当前类的数据成员就要加 `const`，明确语义，增加可读性。 **但，远不止如此**。

 ```cpp
#include <iostream>

class Date {
    using Month = int;
public:
    Month m;

    int month() { return m; }          
};

void func(const Date& date){
    std::cout << date.month() << '\n';
}

int main(){
    Date d{10};
    func(d);
} 
```

以上代码会得到一个编译错误，这应该是很常见的调用方式。

为什么呢？显然，就是因为 `month` 成员函数没有以 `const` 修饰。

`C++` 不允许 const 的对象调用没有以 const 修饰的成员函数，事实上这个语义非常的合理：我都是 const 对象了，你为啥要修改？

但是明明 `month` 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。

如果你阅读过 `STL` 源码，或者看过基本的[文档](https://zh.cppreference.com/w/cpp/container/array)，会知道，大部分成员函数都要提供 `const` ，和非 `const` 修饰版本，他们的行为也并不完全一样。

不过当前的语境很简单，我们只需要改成：

```cpp
Month month()const { return m; } //const对象和非const对象都能调用
```

相对于 标准库（STL）的算法，使用 for 或 while 等方式的手工循环通常也有上面一样的可读性问题。比如下面这样：

```cpp
int index = -1;                          //不好
for (int i = 0; i < v.size(); ++i){
    if(v[i]==val){
        index = i;
        break;
    }
}

auto it = std::find(begin(v),end(v),val); //更好
```

一个专业的 C++ 开发者应该了解 **STL 算法**。使用它们的话，你就可以避免显式使用循环，你的代码也会变得更容易理解，更容易维护，因此，也更不容易出错。现代 C++ 中有一句谚语：

* *如果你显式使用循环的话，说明你不了解 STL 算法。*

> 其实就是说成员函数注意返回类型的名字，和 const 修饰，增加可读性。
> 多使用 STL 算法，而不是自己搓，既能增加可读性也能减少错误。

## P.2 用 ISO 标准写代码

要想得到一个可移植的 C++ 程序，最好的选择就是按照标准写代码。

使用当前的 C++ 标准，不要使用编译器扩展，同时注意，[未定义行为和实现定义行为](https://zh.cppreference.com/w/cpp/language/ub)。

**当你必须使用没有写在 ISO 标准里的扩展时，可以用一个稳定的接口将它们封装起来。** 

> 比如将使用的编译器扩展用宏封装起来，以后如果要修改，或者说要适应别的平台，都很方便。举一个古代[例子](https://godbolt.org/z/jGfGz941G)：

```cpp
#if __cplusplus >= 201103L
#define INLINE inline
#else
#define INLINE __attribute__((__always_inline__))
#endif
```

* *会着火的语义*
   当你的程序有未定义行为时，你的程序有”着火“语义 —— *你的计算机可能会着火*。

## P.3 表达意图

以下的隐式和显式循环中，你能看出什么意图？

```cpp
for (const auto& v: vec) {...}                              // (1)
for (auto& v: vec) {...}                                    // (2)
std::for_each(std::execution::par, vec, [](auto v) {...});  // (3)
```

循环（1）不修改容器 vec 的元素。（2）有可能修改。算法 [std::for_each](https://zh.cppreference.com/w/cpp/algorithm/for_each)（3）以并行方式（[std::execution::par](https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t)）执行。这意味着我们不关心处理的顺序。[举个例子](https://godbolt.org/z/hxfdnT6W8)：

```cpp
int main(){
    std::vector<int>vec{1, 2, 3, 4, 5};
    std::for_each(std::execution::par, vec.begin(), vec.end(), [](auto v) {std::cout << v; });//打印的顺序是随机的
    std::cout << '\n';
    std::for_each(vec.begin(), vec.end(), [](auto v) {std::cout << v; });                     //12345
}
```

表达意图也是良好代码文档的一个重要准测。

* *文档应该说明代码会做什么，而不是代码会怎么做*。

> 其实这里是在指，文档应该讲功能，而非实现细节。
> 不过事实上技术文档一般都不会完全这样，多少会提一些实现细节的，具体情况具体分析。

## P.4 理想情况下，程序应该是静态类型安全的

C++ 是一种静态类型的语言。静态类型意味着编译器知道数据的类型，此外，还说明，编译器可以检测到类型错误。
由于现有的问题领域，我们并非一直能够达到这一目标，但对于联合体、转型(cast)、数组退化、范围错误或窄化转换，确实是有办法的。

* 在 C++17 中，可以使用 [std::variant](https://zh.cppreference.com/w/cpp/utility/variant) 安全地替代[联合体](https://zh.cppreference.com/w/cpp/language/union)。
  
* 基于模板的泛型代码减少了转型的需要，因此，也减少了类型错误。
  
* 当用一个 C 数组调用一个函数时，就会发生[数组退化](https://zh.cppreference.com/w/cpp/language/implicit_conversion)。函数需要用指向数组第一个元素的指针，另加数组的长度。这意味着，你从一个类型丰富的数据结构 C 数组开始，却以类型极差的数组首项指针结束。[解决方法](https://godbolt.org/z/KPPcP5j89)在 C++20 里：[std::span](https://zh.cppreference.com/w/cpp/container/span)。std::span 可以自动推算出 C 数组的大小，也可以防止范围错误的发生。如果你还没有使用 C++20，请使用 Guidelines 支持库（GSL）提供的实现。
  
* [窄化转换](https://zh.cppreference.com/w/cpp/language/list_initialization)是对算术值的有精度损失的隐式转换。

```cpp
int i1(3.14);
int i2 = 3.14;
```

如果你使用 {} 初始化语法，编译器就能[检测到窄化转换](https://godbolt.org/z/j6GTbGvvn)。

```cpp
int i1{3.14};
int i2 = {3.14};
```
