# 函数

理念性规则概览：

- [函数](#函数)
  - [4.1 函数定义](#41-函数定义)
    - [好名字](#好名字)
    - [F.4 如果函数有可能需要再编译期求值，就把它声明为 constexpr](#f4-如果函数有可能需要再编译期求值就把它声明为-constexpr)
    - [F.6 如果你的函数必定不抛出异常，就把它声明为 noexcept](#f6-如果你的函数必定不抛出异常就把它声明为-noexcept)
    - [F.8 优先使用纯函数](#f8-优先使用纯函数)
  - [4.2 参数传递：入与出](#42-参数传递入与出)
    - [F.15 优先采用简单而约定俗成的信息传递方式](#f15-优先采用简单而约定俗成的信息传递方式)
    - [F.16 对于 "入"参，拷贝开销低的类型按值传递，其他类型则以 const 引用来传递](#f16-对于-入参拷贝开销低的类型按值传递其他类型则以-const-引用来传递)

## 4.1 函数定义

- *好软件的重要原则是好名字*。

这一原则经常被忽视，但对函数而言它尤其适用。

### 好名字

C++ Core Guidelines 用了前三条规则专门讨论好的名字：“F.1：将有意义的操作 ‘打包’ 成精心命名的函数” “F.2：一个函数应该执行单一的逻辑操作” “F.3：使函数保持简短”。

让我从一则轶事开始。几年前，一位软件开发者问我：“我应该如何称呼我的函数？”我告诉他给函数起一个如 verbObject（动词加对象）这样的名字。如果是成员函数，可能用 verb 就可以了，因为该函数已经对一个对象执行了操作。动词代表了对象执行的操作。那位软件开发者反驳这是不可能的；该函数必须被称为 getTimeAndAddToPhonebook 或 processData，因为这些函数执行不止一项工作（单一责任原则）。

- *当你无法为函数找到一个有意义的名称（F.1）时，这充分说明你的函数执行不止一项逻辑操作（F.2），而且你的函数并不简短（F.3）*。

如果一个函数放不进一屏，那就是太长了。一屏意味着大约 60 行，每行 140 个字符，但你的衡量标准可能有所不同。这时，你就应该识别出函数的操作，并将这些操作打包成精心命名的函数。

```cpp
void read_and_print(){      //不好
    int x;
    std::cin >> x;
    //检查错误
    std::cout << x << '\n';
}
```

由于许多原因，函数 read_and_print 不好。该函数与特定的输入和输出捆绑在一起，不能在不同的上下文中使用。将该函数重构为两个函数，可以解决这些问题，使其更易于测试和维护。

```cpp
int read(std::istream&is){ //更好
    int x;
    is >> x;
    return x;
}

void print(std::ostream&os,int x){
    os << x << '\n';
}
```

> 这里写个使用示例吧：

```cpp
#include<iostream>
#include<sstream>

int read(std::istream&is){ //更好
    int x;
    is >> x;
    return x;
}

void print(std::ostream&os,int x){
    os << x << ' ';
}

int main(){
    std::stringstream s{"10 "};
    auto result = read(s);          //从 stringstream 中读取
    print(std::cout, result);       //输出到标准输出中

    std::cout << s.str() << '\n';   //打印 stringstream 中的内容

    print(s,6);                     //输出到 stringstream 中。
    print(s,7);                     //输出到 stringstream 中。
    print(s,8);                     //输出到 stringstream 中。

    std::cout << s.str() << '\n';   //打印 stringstream 中的内容

    s.seekg(0);                     //需要进行回溯，因为默认读取位置在上一个read到的位置
    auto result2 = read(s);
    std::cout << result2 << '\n';   //从 stringstream 中读取
}
```

[运行结果](https://godbolt.org/z/45z4Kj5rM)：

```text
10 10 
6 7 8 
6
```

### F.4 如果函数有可能需要再编译期求值，就把它声明为 constexpr

constexpr 函数是可能在编译期运行的函数。当你在常量表达式中调用 constexpr 函数时，或者当你要用一个 constexpr 变量来获取 constexpr 函数的结果时，它会在编译期运行。也可以用只能在运行期求值的参数来调用 constexpr 函数。constexpr 函数是隐含内联的。

编译期求值的 constexpr 的结果通常会被系统标记为只读。性能是 constexpr 函数的一大好处；它的第二大好处是：

**编译期求值的 constexpr 是纯函数，因此 constexpr 函数是线程安全的**。

> 加粗这句话是因为这句话是 **错误** 的。

- “constexpr 函数是线程安全的”

完全错误。

这里其实主要涉及到一个问题：至少存在一组实参值，使得函数的一个调用为核心常量表达式的被求值的子表达式（对于构造函数为足以用于常量初始化器） (C++14 起)。**不要求诊断是否违反这点**。

```cpp
#include <iostream>
int n = 5;
constexpr int f(int v){//永远不可能编译期求值
    n *= n;
    return n * v;
}

int main(){
    std::cout << f(1) << '\n';
}//可能可以通过编译，也可能不行
```

- “编译期求值的 constexpr 函数是纯函数“

完全错误

```cpp
#include<iostream>

constexpr int f(int &v){
    v +=2;
    return v * v;
}

constexpr std::pair<int,int> call(){
    int v = 1;
    auto r1 = f(v);
    auto r2 = f(v);
    return { r1,r2 };
}

int main(){
    constexpr auto result = call();
    std::cout << result.first << ' ' << result.second << '\n';
}
```

我的函数 f **的确是编译期求值**，没毛病，难不成它是[纯函数](https://en.m.wikipedia.org/wiki/Pure_function)？你要不看看它都做了什么.

> 我们回到前面的性能话题

```cpp
constexpr auto gcd(int a,int b){
    while(b!=0){
        auto t = b;
        b = a % b;
        a = t;
    }
    return a;
}

int main(){
    constexpr int i = gcd(11, 121); //（1）编译期求值

    int a = 11;
    int b = 121;
    int j = gcd(a, b);              //（2）非编译期求值
}
```

> 原书这里是要你看[汇编](https://godbolt.org/z/qjzxxv5oe)的，，唉，其实无所谓，看看吧。友情提示，别开优化，这么点代码，开优化，啥 call 都没有。
> 下面是使用 gcc13.2 生成的 Intel 风格的汇编代码。

![汇编](../image/C++CoreGuidelines/4.1.png)

（1）所对应汇编指令就是 26行。（2）所对应的汇编指令就是 31~34 行。

调用 `constexpr int i = gcd(11, 121);` 会变成值 11，但调用 `int j = gcd(a, b);` 却会产生一个函数调用。

### F.6 如果你的函数必定不抛出异常，就把它声明为 noexcept

通过将函数声明为 noexcept，你减少了备选控制路径的数量；因此，noexcept 对优化器来说是一个有价值的提示。

- *即使你的函数可以抛出异常，noexcept 往往也合理*。

noexcept 在这种情况下意味着：

- *我不在乎异常。其原因可能是，你无法对异常做出反应*。

这种情况下，系统处理异常的唯一办法是调用 [std::terminate()](https://zh.cppreference.com/w/cpp/error/terminate)。这个 noexcept 声明也为代码的读者提供了有价值的信息。

下面的函数会在内存耗尽时崩溃。

```cpp
std::vector<std::string> collect(std::istream& is)noexcept{
    std::vector<std::string>res;
    for (std::string s; is >> s;) {
        res.push_back(s);
    }
    return res;
}
```

以下类型的函数永远不该抛出异常：析构函数（见第 5 章中 “失败的析构函数” 一节）、swap 函数，移动操作和默认构造函数。

### F.8 优先使用纯函数

- *纯函数是指在给定相同参数时总返回相同结果的函数*。

> 其实还有：该函数没有副作用（局部静态变量、非局部变量、可变引用参数或输入/输出流没有突变）。下面也略微提到了。

函数模板 square 就是纯函数：

```cpp
template<class T>
auto square(T t){
    return t * t;
}
```

而非纯函数是指 random() 或 time() 这样的函数，**它们会在不同的调用中返回不同的结果**。换句话说：

- *与函数体之外的状态交互的函数是不纯的*。

纯函数可以：

- 孤立地侧测试
- 孤立地验证或重构
- [缓存其结果](https://github.com/Mq-b/Loser-HomeWork/blob/main/C%2B%2BCoreGuidelines%E8%A7%A3%E6%9E%90/%E7%AC%AC3%E7%AB%A0-%E6%8E%A5%E5%8F%A3.md#i2-%E9%81%BF%E5%85%8D%E9%9D%9E-const-%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F)
- 被自动重排或在其他线程上执行

纯函数也被称为数学函数。C++ 中的函数默认情况下不是像纯函数式编程语言 Haskell 中那样的纯函数。 在 C++ 中使用纯函数时要基于程序员的素养。**constexpr 函数在编译期求值时是纯的**。

> 加粗的原因很简单，因为这句话是**错的** 在 [`F.4`](#f4-如果函数有可能需要再编译期求值就把它声明为-constexpr) 已经介绍过了。

模板元编程时一种嵌在命令式语言 C++ 中的纯函数式语言。

第 13 章将简单介绍编译期编程，其中包括模板元编程。

## 4.2 参数传递：入与出

C++ Core Guidelines 有若干条规则表达了在函数中传入和传出参数的各种方式。

### F.15 优先采用简单而约定俗成的信息传递方式

第一条规则展示了大局。首先，它提供了一个概览，介绍了在函数中传入和传出信息的各种方式（见表 4.1）

表 4.1 很简洁：表头表述了数据在拷贝和移动开销方面的特征，而各行则表明了参数传递的方向。

<table align="center" border="0">
<p align="center"><b>表 4.1 普通的参数传递</b></p>
    <tr>
         <td></td>
         <td><b>拷贝开销低或不可能拷贝</b></td>
         <td><b>移动开销低到中，或者未知</b></td>
         <td><b>移动开销高</b></td>
    </tr>
    <tr>
         <td align="center"><b>入</b></td>
         <td rowspan="2" align="center">func(x)</td>
         <td rowspan="2" colspan="2" align="center">func(const X&)</td>
    </tr>
    <tr>
         <td><b>入并保留“拷贝</b>”</td>
    </tr>
    <tr>
     <td><b>入/出</b></td>
     <td colspan="3" align="center">func(X&)</td>
    </tr>
    <tr>
     <td><b>出</b></td>
     <td colspan="2" align="center">X func()</td>
     <td align="center">func(X&)</td>
    </tr>
</table>

- 数据类型

  - **拷贝开销低或不可能拷贝**：`int` 或 `std::unique_ptr`
  - **移动开销低**：`std::vector<T>` 或 `BigPOD`（POD 代表 Old Data “简旧数据”，意为一般的传统数据——没有析构函数、构造函数以及虚成员函数的类）
  - **移动开销未知**：模板
  - **移动开销高**：`BigPOD[]` 或者 `std::array<BigPOD>`
- 参数传递的方向

  - **入**：输入参数
  - **入并保留“拷贝”**：被调用者保留一份数据
  - **入/出**：参数会被修改
  - **出**：输出参数

对几个 int 大小的数据的操作是低开销的；在不进行内存分配的前提下，1000 字节左右的操作属于中等开销。

这些普通的参数传递规则则应当是你的首选。不过，也有高级的参数传递规则（见表4.2）。实质上，就是加入了“入并移入”的语义。

<table align="center" border="0">
<p align="center"><b>表 4.2 高级的参数传递</b></p>
    <tr>
         <td></td>
         <td><b>拷贝开销低或不可能拷贝</b></td>
         <td><b>移动开销低到中，或者未知</b></td>
         <td><b>移动开销高</b></td>
    </tr>
    <tr>
         <td align="center"><b>入</b></td>
         <td rowspan="2" align="center">func(x)</td>
         <td rowspan="2" colspan="2" align="center">func(const X&)</td>
    </tr>
    <tr>
         <td><b>入并保留“拷贝</b>”</td>
    </tr>
    <tr>
         <td><b>入并移入</b></td>
         <td colspan="3" align="center">func(X&&)</td>
    </tr>
    <tr>
     <td><b>入/出</b></td>
     <td colspan="3" align="center">func(X&)</td>
    </tr>
    <tr>
     <td><b>出</b></td>
     <td colspan="2" align="center">X func()</td>
     <td align="center">func(X&)</td>
    </tr>
</table>

> 这两个表的 “**出**” 用的 `func(X&)` 其实是指代那种老式的写法，传入参数做传出参数，Win32中很常见。
> “**不可能拷贝**” 其实是指：`f(X{})` 这种形式，C++17 起强制的复制消除，不可能再复制。
> “**入并移入**” 就是让你 `f(std::move(...))`。

在 “入并移入” 调用后，参数处在所谓的被移动状态。被移动状态意味着它处于合法但未指定的状态。基本上，你在重新使用被移动的对象前必须对它进行初始化。

其余的参数传递规则为以上这些表格提供了必要的背景信息。

### F.16 对于 "入"参，拷贝开销低的类型按值传递，其他类型则以 const 引用来传递

这条规则执行起来直截了当。默认情况下，输入值可以拷贝就拷贝。如果拷贝开销不低，就通过 const 引用来传入。C++ Core Guidelines 给出了回答以下问题的经验法则：

**哪些对象拷贝开销低？哪些对象拷贝高？**

- *如果 `sizeof(par) <= 2 * sizeof(void*)`，则按值传递参数 par*。
- *如果 `sizeof(par) > 2 * sizeof(void*)`，则按 const 引用 传递参数 par*。

```cpp
void f()(const std::string& s);  // 可以：按 const 的引用传递；
                                 // 总是低开销
                                
void f2(std::string s);          // 差劲：潜在的高昂开销

void f3(int x);                  // 可以：无可匹敌

void f4(const int& x);           // 差劲：在 f4() 里面访问时有额外开销
```

### F.19 对于“转发”参数，要用 Tp&& 来传递，并且只 std::forward 该参数