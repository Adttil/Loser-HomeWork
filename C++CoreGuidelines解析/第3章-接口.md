# 接口

接口性规则概览：

- [接口](#接口)
  - [I.2 避免非 const 的全局变量](#i2-避免非-const-的全局变量)
  - [3.1 非 const 全局变量的弊端](#31-非-const-全局变量的弊端)
  - [I.3 避免单例](#i3-避免单例)

接口是服务的提供者和使用者之间的契约。根据 C++ Core Guidelines，接口”可能是代码辅助中最重要的一个方面”。“接口”这一部分大约有 20 条规则。

- *让接口易于正确使用，难以错误使用*。

## I.2 避免非 const 的全局变量

当然，你应该避免非 const 的全局变量。但是为什么呢？为什么全局变量（尤其是当它不是常量时）会很糟糕？**全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分**。下面的代码片段说明了我的观点：

> 加粗的话注意理解。

```cpp
int glob{ 2011 };

int multiply(int fac){
    glob *= glob;
    return glob * fac;
}
```

函数 multiply 的执行有一个副作用——会改变全局变量 glob 的值。因此，**你无法对函数进行孤立测试或推理**。当更多的线程并发地使用 multiply 时，你就必须对变量 glob 加以保护。非 const 的全局变量还有更多其他弊端。**如果函数 multiply 没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用。**

> 注意到我们加粗的内容了吗？这非常重要，自行理解。
> 我们就讲一下最后一句，这其实是在描述**编译器优化** ，我们举个例子：什么情况才可能会是我们说的：**没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用**。

```cpp
int add(int a,int b){
    return a + b;
}

int main(){
    int c = add(1, 2) + add(1, 2) + add(1, 3);
}
```

其实无非就是：编译器看到你用同样的入参调用了两次 就可以干掉第二次调用。之前的结果被缓存了。（前提是这得是[纯函数](https://en.m.wikipedia.org/wiki/Pure_function)）。

但是我们前面依赖了全局变量，就不行，它有外部的副作用，返回的结果可能会根据全局变量的不同而不同，没办法缓存。不能保证：**多次调用传入的数据相同就能得到完全一致的结果**。

## 3.1 非 const 全局变量的弊端

非 const 的全局变量有许多弊端。首当其冲的弊端是，**非 const 的全局变量破坏了封装。这种对封面的破坏让你无法对函数/类（实体）进行独立思考**。下面列举非 const 全局变量的主要弊端。

- **可测试性**：无法孤立地测试你的实体。如果单元不存在，那么单元测试也将不存在。你只能进行系统测试。实体的执行效果要依赖整个系统状态。
- **重构**：因为你无法孤立地对代码进行推理，重构它会相当有挑战。
- **优化**：你无法轻易地重新安排函数调用或者在不同的线程上进行函数调用，因为可能有隐藏的依赖。缓存之前函数调用的结果也极为危险。
- **并发**：产生数据竞争的必要条件是有共享而可变的状态。而非 const 全局变量正是共享而可变的。

## I.3 避免单例