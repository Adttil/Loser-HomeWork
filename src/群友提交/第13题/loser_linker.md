```c++
X f(){
    X x;
    return std::move(x);
}
```
没问题。作用是使用移动构造来构造返回值，来避免对临时量无意义的复制操作。但在c++17强制要求复制清除以后，就不推荐再这样使用std::move了,直接返回更好，如果不依赖构造返回值操作的话。
```c++
X&& f(){
    X x;
    return std::move(x);
}
```
有问题。问题出在触发引用悬挂。返回临时量的引用，右值引用也是引用，不是只有左值引用才算引用，返回的右值引用谬构，程序行为未定义。
```c++
struct Test {
    X x;
    X f() {
        return std::move(x);
    }
};
```
没问题。用来移出成员变量,因为成员变量不是默认可移动实体，需要转成右值引用来强制移动操作。不过，典型的移动构造函数“窃取”实参曾保有的资源（例如指向动态分配对象的指针，文件描述符，TCP socket，输入输出流，运行的线程，等等），而非复制它们，并使它的实参遗留在某个合法但不确定的状态。例如，从 std::string 或从 std::vector 移动可以导致实参被置为空。但是不应该依赖此类行为。