# 20231017 基础C++题目

## 题目

### 1. 下面展示的代码应当使用：
```C++
struct Base { int x; };
struct Derived : Base { int y; }

int get_xy(Base * param){
    auto pd = ????_cast<Derived*>(param);
    return pd->x * pd->y;
}
```
- A. static_cast
- B. dynamic_cast
- C. 以上全部
- D. 不允许转换

### 2. 下面展示的代码应当使用：
```C++
void erased_call(void (* pfn)(void), const char * param){
    auto typed_pfn = ????_cast<void(*)(const char *)>(pfn);
    typed_pfn(param);
}
```
- A. static_cast
- B. reinterpret_cast
- C. 以上全部
- D. 不允许转换

### 3. 下面展示的代码应当使用：
```C++
template<typename T>
void foo(T&& i){
    // some implemetion code
}

void speciallized_foo(int param){
    auto spfoo = ????_cast<void(*)(const double&)>(foo);
    spfoo(param);
}
```
- A. static_cast
- B. reinterpret_cast  
- C. 以上全部
- D. 不允许转换

## 答案

1. A
2. B
3. A

## 解析

1. 此处`Base`并非多态类型，因此`dynamic_cast`无法使用，而`static_cast`可以用于基类指针到派生类指针的转换。
   * 你可以为`Base`添加虚函数成员，使其成为多态类型，此时`dynamic_cast`可以用于基类到派生类的转换。  
   * 注意`static_cast`并不像`dynamic_cast`那样具有RTTI，无法转换时不会得到`nullptr`，通过不合法的转换得到的指针访问成员会得到未定义行为。
2. `reinterpret_cast`可以用于函数指针的转换，而`static_cast`不可以。
   * 此处`reinterpret_cast`并不会产生实际转换代码。
   * 普通指针`void *`和函数指针`void (*)(void)`在一些平台上的长度不同，C++标准并不保证这两种类型能够以`reinterpret_cast`互相转换。  
3. `static_cast`可以用于将模板函数转换到特定特化。